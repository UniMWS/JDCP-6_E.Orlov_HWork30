package ru.netology;

// Application ClassLoader (классы приложения) начинает поиск класса для загрузки и по принципу наследования
// передаёт запрос дальше в Platform ClassLoader (внешние классы),
// после ищет у себя Bootstrap ClassLoader (встроенные в java) для продолжения загрузки.
// Если не находит, то поиск возвращается по обратной цепочке. Ошибка, если нет нигде.
// Когда найден - загрузка данных о классе и констант в MetaSpace через связывание - linking:
// Verify - проверка кода на валидность,
// Prepare - подготовка: выделяется место хранения в памяти под статические поля и объекты,
// Resolve - разрешение символьных ссылок: превращение динамических в указатели на реальные объекты.
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1 - фрейм `main` в стеке, `i` в этом фрейме
        Object o = new Object();        // 2 - `Object` в кучу, `new` создаёт ссылку `o` в фрейме `main`
        Integer ii = 2;                 // 3 - значение `2` в объекте `Integer` в куче, ссылка `ii` в фрейме `main`
        printAll(o, i, ii);             // 4 - фрейм `printAll` в стеке,
        // копия примитива `i` и новые ссылки `o` и `ii` в этом фрейме
        System.out.println("finished"); // 7 - закрытие фрейма `printAll`, сборщик мусора может удалять `uselessVar`,
        // создание фрейма `println` в стеке, создание объекта `String` со значением "finished" в куче и
        // передача ссылки на него в фрейм `println`, после отрабатывания и закрытия фрейма `println`,
        // сборщик мусора может удалять объект `String` из кучи.
    }
    // закрылся фрейм `main` в стеке с удалением примитива `i` и ссылок `o` и `ii`,
    // сборщик мусора может удалять объекты `Object` и `Integer` в куче.

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5 - `Integer` значение `700` в куче,
        // ссылка `uselessVar` в фрейме `printAll`
        System.out.println(o.toString() + i + ii);  // 6 - создание отдельного фрейма вычисления в стеке,
        // в нём копия `i` и ссылки на `o` и `ii`, отработал новый фрейм `toString` в стеке и
        // передал значение `toString()` объекту `o`, вычисление значения `(o.toString() + i + ii)` и
        // сборщик мусора может чистить остатки фрейма `toString`,
        // создание фрейма `println` в стеке и передача в него значения вычисления `(o.toString() + i + ii)`,
        // закрытие фрейма вычисления, сборщик мусора может удалять его остатки: `o.toString()`, `i`, `ii`,
        // отработал и закрылся фрейм `println`, сборщик мусора может удалять значение `(o.toString() + i + ii)`.
    }
}